# 1 算法性能分析

## 1.1 代码的内存消耗

1. C/C++这种内存堆空间的申请和释放完全靠自己管理
2. Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出
3. Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。

### 1.1.1 C++的内存管理

![image-20211231145712120](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211231145712120.png)

* 栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
* 堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回，**造成内存泄漏的发源地。**
* 未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量
* 初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量
* 程序代码区(Text)：存放函数体的二进制代码

代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存主要看可变部分。在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。

**而Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情**



### 1.1.2 内存对齐

**不要以为只有C/C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的**。

> **为什么会有内存对齐？**

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
2. 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。（假设是int）
   1. 对齐：直接将地址处的字节数据读取到即可。![image-20211231190511728](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211231190511728.png)
   2. 未对齐：可能需要两次寻址，一次合并的操作![image-20211231190519089](https://raw.githubusercontent.com/shen-shang66666/Pic/main/img/image-20211231190519089.png)
3. 尽管造成了内存资源的浪费，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

**编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响**。



1. * 